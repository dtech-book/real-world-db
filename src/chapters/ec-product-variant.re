= 商品マスタの設計

本章では、実際のプロダクトに使われているECシステムの商品マスタの設計を紹介します。
ECのオープンソースプロダクトであるSpreeおよびEC-CUBEの商品マスタを取り上げ、
最適な商品データベース設計は何かを考えていきます。

== バリエーションを持つ商品

多くのECシステムでは、商品にバリエーションを持たせることができます。
商品のバリエーションとは何でしょうか。

例えばTシャツを販売しているECを運用しているとしましょう。
同じTシャツでも、色違い、サイズの違いといったように、同じ商品で特定の特性だけが異なるデータを持たせたいことがあります(@<img>{ec-product-variant-variation-intro})。
Spreeでは、これら特性の違う商品を@<strong>{バリアント}と呼び、EC-CUBEでは@<strong>{規格}と呼んでいます。

//image[ec-product-variant-variation-intro][商品と商品バリエーション][scale=1.0]


今後、バリアントおよび規格のことを、本書では@<strong>{商品バリエーション}と呼ぶことにします。


=== Spreeの商品バリエーションの設計

Spreeは、商品バリエーションを@<img>{ec-product-variant-spree-product-er}のようなテーブルで保持します。

//image[ec-product-variant-spree-product-er][Spreeの商品と商品バリエーションの関係][scale=1.0]

==== 商品テーブル

商品テーブルでは、商品名・商品の説明といった商品の基本情報を持ちます。

==== 商品バリエーション

商品バリエーションテーブルは、バリエーションごとの情報を持つテーブルです。
SKU(スキュー: 在庫管理を行うときの最小の単位)や価格の情報を持ちます。
ショップの利用者は商品バリエーション単位で商品を買います。

1つの商品は@<b>{1つ以上}の商品バリエーションを持ちます(@<img>{ec-product-variant-spree-rel})。
1つ目のバリエーションレコードを、マスタバリエーションと呼びます。
たとえバリエーションを持たない商品であっても、マスタバリエーションは必要です。

//image[ec-product-variant-spree-rel][商品バリエーションのレコードの持ち方][scale=1.0]

バリエーションを新たに追加した際は、マスタバリエーションから情報を引き継いで新しいレコードが作成されます。

  * バリエーションを必要としない商品の場合
	** マスタバリエーションに商品の価格情報など商品基本情報を持ちます
	** ショップ利用者はマスタバリエーションをカートに入れて購入できます
	* バリエーションを必要とする商品の場合
	** マスタバリエーションは単なるダミーデータです
	** バリエーションが存在する場合は、ショップ利用者はマスタバリエーションを購入できません
	** マスタバリエーションとは別に、バリエーションのパターンごとに商品バリエーションレコードを持ちます


==== オプションタイプ / オプション値

商品の特性を管理するための情報を持ちます。
オプションタイプは、例えば商品のサイズや色といった情報を持ちます。
オプション値は、サイズに対するS/M/L、色に対する赤/青といった情報を持ちます(@<img>{ec-product-variant-spree-option})。

//image[ec-product-variant-spree-option][Spreeのオプション][scale=1.0]

商品バリエーションとオプションを@<img>{ec-product-variant-spree-p2}のように関連付けることでバリエーションを表現しています。

//image[ec-product-variant-spree-p2][Spreeの商品バリエーションとオプションの関連][scale=1.0]


==== バリエーション/オプション関連

あるテーブルの複数のレコードが複数の別のテーブルと関連付けられている状態を、多対多のリレーションを持っている状態と呼びます。
商品バリエーションとオプションは多対多のリレーションを持つことができます。

Tシャツを販売している場合、@<img>{ec-product-variant-spree-p3}のように、サイズと色の組み合わせの商品バリエーションを作成できます。


//image[ec-product-variant-spree-p3][複数のバリエーションをもつ商品][scale=1.0]


多対多のリレーションは中間テーブルを持つことで表現でき、バリエーション/オプション関連テーブルは中間テーブルです。
商品バリエーションとオプションは、@<img>{ec-product-variant-spree-option-value-rel}のようなレコードで表現します。


//image[ec-product-variant-spree-option-value-rel][Spreeの商品バリエーションとオプションの関連][scale=1.0]


=== EC-CUBEの商品バリエーションの設計

EC-CUBEは、商品バリエーションを@<img>{ec-product-variant-eccube-product-model}のようなテーブルで保持します。

//image[ec-product-variant-eccube-product-model][EC-CUBEの商品バリエーション]

データの持ち方はSpreeと似ています。Spreeと異なる箇所のみ説明します。

==== 商品規格情報

商品規格情報テーブルは、バリエーションごとの情報を持つテーブルです。
1つの商品は1つ以上のバリエーションを持ちます。

バリエーションを必要としない商品であっても、商品と商品規格情報テーブルは1:1の関連で必ずバリエーションのレコードを持ちます。
これはSpreeでのマスタフラグ(@<img>{ec-product-variant-spree-rel})と考え方は全く同じです。
バリエーションが必要な場合は、(表示フラグで非表示状態とした)ダミーレコードを1つ持ちつつ、バリエーションごとのレコード情報を新たに持ちます。

商品規格情報と規格分類情報との関連付けが、Spreeと異なります。
EC-CUBEでは、商品規格情報テーブルに分類へのIDを直接持っています。
分類IDは2つまで設定できるよう、分類情報ID_1 と 分類情報ID_2 の2つが用意されています。


=== バリエーションは最大何パターンあるか

商品のバリエーションが1パターンと決まっており、この前提が崩れないのであれば、
EC-CUBEのテーブル設計のように商品バリエーションテーブルに直接バリエーション(EC-CUBEでの規格分類情報)へのIDを持たせたほうが
実装はシンプルです(@<img>{ec-product-variant-pattern1})。


//image[ec-product-variant-pattern1][EC-CUBE方式 商品バリエーションとバリエーションを直接関連付ける]


バリエーションの組み合わせが2つ以上になる可能性がある場合、EC-CUBEのように
複数のバリエーションIDを同じテーブルで持つことはおすすめしません。

EC-CUBE方式の商品設計だと、バリエーションの組み合わせは最大2パターンまでしか追加できません。
3パターン目のバリエーションが登場した場合は、このテーブル設計だと対応できません。
Tシャツを販売しているとして、色×サイズ×素材 のように3パターンの組み合わせでバリエーションを作る可能性もあります。

テーブルに複数の同じ意味を持つカラムを定義するのは、@<b>{マルチカラムアトリビュート}というアンチパターンです。
マルチカラムアトリビュートでは、次の問題が発生します。

 * 値の検索が複雑になる
 ** バリエーションの検索時、ID1 / ID2 の2つのカラムを対象として検索をかける必要があります
 * 値の一意性を保証できない
 ** ID1 と ID2 に同じ値が入ってしまう問題をデータベースレベルで防ぐことができません
 * バリエーションの組み合わせが増えた場合に、カラムをさらに追加する必要がある
 ** 組み合わせが2パターンから3パターンに増えた場合、ID1 / ID2 に加えて ID3を追加を追加しなければならず、さらにIDが増えたことにより既存の検索条件も変更しなければなりません

Spree方式の設計では、商品のバリエーションの組み合わせに上限はありません。
商品バリエーションとバリエーション間に中間テーブルを挟むことで、いくらでも組み合わせを増やすことができます(@<img>{ec-product-variant-pattern2})。


//image[ec-product-variant-pattern2][Spree方式 商品バリエーションとバリエーションの間に中間テーブルをはさむ]


 * バリエーションのパターンが1つだけとわかっている場合
 ** @<img>{ec-product-variant-pattern1}のように商品バリエーションとバリエーションを直接紐付けることをおすすめします
 * 2つ以上になる可能性がある場合
 ** @<img>{ec-product-variant-pattern2}のように中間テーブルを挟むことをおすすめします


=== バリエーションが存在しない商品のレコードの持ち方

商品と商品バリエーションテーブルは、1対1または1対多である必要があります。
バリエーションが存在しない商品であっても、この前提は崩れません。
Spreeでは1つの商品に対して、商品バリエーションテーブルのマスタレコードが必ず必要です。EC-CUBEのテーブル設計でも同じです。

商品バリエーションテーブルは、SKUや商品価格、商品原価を持っています。

バリエーションが存在しないのに、マスタレコードは本当に必要でしょうか。
バリエーションが存在する場合でも、マスタレコードを1つ持たなければなりません。

@<img>{ec-product-variant-variant-dummy}の左側のように、
バリエーションが必要ない場合は商品レコードのみで商品を表現し、
バリエーションを持つときのみ商品バリエーションのレコードを持つ方法はどうでしょうか。


//image[ec-product-variant-variant-dummy][商品バリエーションテーブルにマスタレコードは必要か]


テーブル設計では、@<b>{One Fact in One Place(1つの事実は1つの場所にのみ存在する)}を徹底していくのが基本です。
同じ項目が複数のテーブルに存在するのは避けるべきです。

商品バリエーションテーブルにはSKUや価格情報を持っています。
マスタレコードがない場合は、これらの情報を商品テーブルに持たなければならず、同じ項目が複数テーブルにまたがり存在してしまいます。
商品価格を取るのに、データによって商品テーブルから取り出すか商品バリエーションテーブルから取り出すかの判断をするのは、実装の複雑化をまねきます。

商品をカートに入れ購入する際も、商品テーブルへの関連をカートに持つか、商品バリエーションへの関連を持つかを考えなければなりません。
これもまた複雑な実装です。

商品は必ず1つのマスタレコードを持つと決めておいたほうが、アプリケーション側の実装をシンプルにできます。




== 属性を持つ商品

Spreeでは、商品ごとに属性(プロパティー)を持たせることができます。

属性とは、例えば服であったらブランド名・製造元、食品であったら保存方法・アレルギー情報・賞味期限など、
商品カテゴリーごとに固有の属性のことを指します。

=== Spreeの属性テーブルの設計

Spreeは、商品の属性を@<img>{ec-product-variant-spree-property}のようなテーブルで保持します。

//image[ec-product-variant-spree-property][Spreeの商品と属性の関係]

属性テーブル・商品属性テーブルを使って@<img>{ec-product-variant-spree-property-value}のようにKey-Valueの形でデータを持つことで、商品にどんな属性でも持たせることができます。

//image[ec-product-variant-spree-property-value][Spreeの属性データの持ち方]


=== 属性テーブルを使うのはアンチパターンか

テーブル設計において、属性・商品属性テーブルのようにテーブルの行にKey-Valueの形でデータを保存するのは、@<b>{EAV(エンティティ・アトリビュート・バリュー)というアンチパターン}とされています。
EAVを使ったテーブルは、以下の欠点を持っています。

 * データの型を使えない
 ** Key-ValueのValueにはVarchar/Textのような型を選択する必要があります。入る値が数値や日付であったとしても、文字列型でデータを格納することになります
 * 不正なデータが入り込む可能性がある
 ** データ型が使えないため、本来入ってはいけない値が入り込む可能性があります。数値しか入らない予定の属性に文字列が紛れ込むなどの問題を、データベースレベルで防ぐことはできません
 * データの検索がしにくい / データ取得のSQLが複雑になる
 ** データ型が使えないためSQLが複雑になります。例えば日付、数値の比較するような処理をVarcharで実行するには、データ型変換やケース文を使った複雑なSQLを記述する必要があります
 * データの必須属性を設定できない
 ** Tシャツは必ずブランド名、製造元の値を持つこと、といった制限をデータベースレベルでかけることができません
 * データ量が増える
 ** 1商品に属性がN個存在していた場合は、N行のデータをもつ必要があります


欠点の多いEAVですが、SpreeはEAVを使わざるを得えない事情があります。
SpreeはECサイトを作るプラットフォームであり、商品にどんな属性のデータが入るのかは、あらかじめ定めることはできません。
柔軟性を確保するためには、EAVを選択せざるをえないのです。

あらかじめ扱う商品と属性が決まっているのならば、EAVのようなテーブル設計を選択するべきではありません。


=== 動的な属性の変化をデータベースでサポートできるか

リレーショナルデータベースでは、動的な属性の変化をサポートできません。
データ量が多く、項目が自由に変化する可能性のあるデータを扱わなければならない場合、リレーショナルデータベースを使うべきか検討する必要があります。

MongoDB、Amazon DynamoDBのようなスキーマレスデータベースを使うと、スキーマの定義を必要とせずにデータの追加・変更・削除ができます。


=== 継承を用いた商品テーブル設計

ECで扱う商品の属性があらかじめ決まっている場合、EAVを選択する理由はありません。

例えば、扱う商品は衣類と食品だけと、あらかじめ分かっているとします。

 * 商品カテゴリが衣類の場合
 ** 属性としてブランド名、製造元を持つ
 * 商品カテゴリが食品の場合
 ** 属性として保存方法、アレルギー情報、賞味期限(製造日からの日数)を持つ

この場合、以下戦略をとることができます。

 * STI (Single Table Inheritance / 単一テーブル継承)
 * CCI (Concrete Class Inheritance / 具象テーブル継承)
 * CTI (Class Table Inheritance / クラステーブル継承)

商品全体に共通で持つ項目を集めたスーパータイプと、各商品に固有の情報を保持するサブタイプを用いてデータを表現します(@<img>{ec-product-variant-table-inheritance})。
これはオブジェクト指向における基底クラスと派生クラスのような継承関係を用いるのに似ています。

STI・CCI・CTIは、これらの継承関係を具体的なテーブルに落とし込むための手法です。

//image[ec-product-variant-table-inheritance][スーパータイプとサブタイプ]


==== STI / 単一テーブル継承

STI(単一テーブル継承)は、ひとつのテーブルに関連するすべての属性を格納します(@<list>{ec-product-variant-sti-table-schema}、@<img>{ec-product-variant-sti-data})。
また、各レコードのサブタイプを識別する値をもつ必要があります。

//list[ec-product-variant-sti-table-schema][STIを使った商品テーブル設計][SQL]{
  CREATE TABLE `products` (
    `id` INT(11)                NOT NULL AUTO_INCREMENT,
    `type` VARCHAR(20)          NOT NULL, -- サブタイプを認識するために利用 'Cloth' または 'Food' が入る
    `name` VARCHAR(255)         NOT NULL, -- 商品名
    `brand` VARCHAR(255)                , -- ブランド名 Clothのみ使う
    `manufacturer` VARCHAR(255)         , -- 製造元 Clothのみ使う
    `preservation` VARCHAR(255)         , -- 保存方法 Foodのみ使う
    `allergens`    VARCHAR(255)         , -- アレルギー表示 Foodのみ使う
    `best_before`  INT(11)                -- 賞味期限(製造日からの日数) Foodのみ使う
  );
//}

//image[ec-product-variant-sti-data][STIを使った商品データの持ち方]


 * STIのメリット
 ** EAVと違い、データの型を定義できる
 *** 不正なデータが入り込む可能性を抑えられます
 ** テーブル設計がシンプル
 *** 他の戦略(CCI / CTI)に比べてデータの持ち方がシンプルです
 ** サブタイプをまたいだデータの検索がしやすい
 *** すべてのサブタイプのデータが1つのテーブルに入っているため、サブタイプすべてのレコードを取得・検索といった処理がしやすいです
 * STIのデメリット
 ** サブタイプがどの属性を持つべきかの情報を持っていない
 *** 衣類であったら ブランド名、製造元 カラムを持たなければならないという情報は、テーブル設計を見てもわかりません
 ** 必須カラムを設定できない
 *** あるサブタイプが持つ値は、別のサブタイプではNULLを入れざるを得ません。このため、サブタイプ固有の属性にNOT NULL制約をかけることができません
 ** テーブルが横に長くなる
 *** サブタイプの種類が多く属性も多い場合は、テーブルのカラム数が多くなってしまいます


==== CCI / 具象テーブル継承

CCI(具象テーブル継承)では、各サブタイプごとにテーブルを作成します。
衣類(Cloth)と食品(Food)の商品が必要ならば、@<list>{ec-product-variant-cci-table-schema}、@<img>{ec-product-variant-cci-data}のように2つのテーブルを作成します。

//list[ec-product-variant-cci-table-schema][CCIを使った商品テーブル設計][SQL]{
  CREATE TABLE `clothes` (
    `id` INT(11)                NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(255)         NOT NULL, -- 商品名
    `brand` VARCHAR(255)        NOT NULL, -- ブランド名
    `manufacturer` VARCHAR(255) NOT NULL  -- 製造元
  );

  CREATE TABLE `foods` (
    `id` INT(11)                NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(255)         NOT NULL, -- 商品名
    `preservation` VARCHAR(255) NOT NULL, -- 保存方法
    `allergens`    VARCHAR(255) NOT NULL, -- アレルギー表示
    `best_before`  INT(11)      NOT NULL  -- 賞味期限(製造日からの日数)
  );
//}


//image[ec-product-variant-cci-data][CCIを使った商品データの持ち方]


 * CCIのメリット
 ** サブタイプがどの属性を持つべきか、テーブル設計を見るとわかる
 ** サブタイプ固有の属性にNOT NULL制約をかけることができる
 ** 1テーブルあたりのデータ量をSTIに比べて抑えることができる
 * CCIのデメリット
 ** スーパータイプの項目(すべての商品に共通の項目)が何なのか、テーブル設計を見てもわからない
 ** スーパータイプの項目にUNIQUE制約をかけることができない
 *** 商品名はすべてのサブタイプをまたいで固有である必要がある、といった制約をデータベースレベルでかけることができません
 ** サブタイプをまたいだ検索がしにくい
 *** すべての商品を取得といった処理をするためには、テーブルをUNIONで結合する必要があります
 ** STIに比べアプリケーション側の実装が複雑になる可能性がある
 *** 例えば商品をカートに入れるという操作が必要な場合、カートに入れる商品の参照先が clothesまたはfoodsである必要があります


==== CTI / クラステーブル継承

CTI(クラステーブル継承)では、スーパータイプ、サブタイプそれぞれに対してテーブルを作成します。
具体的には、@<list>{ec-product-variant-cti-table-schema}および@<img>{ec-product-variant-cti-data}のように、
スーパータイプである商品(products)テーブルと、サブタイプである衣類(clothes)・食品(foods)の3テーブルを作成します。

//list[ec-product-variant-cti-table-schema][CTIを使った商品テーブル設計][SQL]{
  CREATE TABLE `products` (
    `id` INT(11)                NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(255)         NOT NULL, -- 商品名
  );

  CREATE TABLE `clothes` (
    `id` INT(11)                 NOT NULL AUTO_INCREMENT,
    `product_id`   INT(11)       NOT NULL, -- 商品ID
    `brand`        VARCHAR(255)  NOT NULL, -- ブランド名
    `manufacturer` VARCHAR(255)  NOT NULL, -- 製造元
    FOREIGN KEY (`product_id`) REFERENCES `products`(`id`)
  );

  CREATE TABLE `foods` (
    `id` INT(11)                NOT NULL AUTO_INCREMENT,
    `product_id`   INT(11)      NOT NULL, -- 商品ID
    `preservation` VARCHAR(255) NOT NULL, -- 保存方法
    `allergens`    VARCHAR(255) NOT NULL, -- アレルギー表示
    `best_before`  INT(11)      NOT NULL, -- 賞味期限(製造日からの日数)
    FOREIGN KEY (`product_id`) REFERENCES `products`(`id`)
  );
//}


//image[ec-product-variant-cti-data][CTIを使った商品データの持ち方]


 * CTIのメリット
 ** スーパータイプ・サブタイプそれぞれがどの属性を持つべきか、テーブル設計を見るとわかる
 ** スーパータイプ・サブタイプそれぞれの属性に、NOT NULL制約やUNIQUE制約をかけることができる
 * CTIのデメリット
 ** レコードを取得するために常にJOINが必要となる
 *** JOINの回数が増えればふえるほど、パフォーマンス上の問題が発生する恐れがあります
 ** 1テーブルあたりのデータ量はCCIに比べて多くなる
 *** 商品(products)テーブルはすべてのサブタイプのレコードをもつ必要があり、レコード数が増える傾向にあります


==== テーブル継承のまとめ

STI・CCI・CTIの特徴は、@<table>{ec-product-variant-inheritance-merideri}のとおりです。

//table[ec-product-variant-inheritance-merideri][STI・CCI・CTIの比較]{
特徴		STI		CCI 		CTI
--------------------------------------------
サブタイプの項目ごとにデータ型を定義できる		○		○ 	○
テーブル設計・アプリケーションの実装がシンプル		○		× 	×
サブタイプをまたいだデータ取得がしやすい		○		× 	×
1テーブルあたりの列数を少なくできる		×		○ 	○
1テーブルあたりの行数を少なくできる		×		○ 	×
サブタイプが持つ属性がテーブル設計からわかる		×		○ 	○
スーパータイプが持つ属性(共通項目)がテーブル設計からわかる		×		× 	○
スーパータイプの属性にUNIQUE制約を設定できる		○		× 	○
サブタイプの属性ごとにNOT NULL制約を設定できる		×		○ 	○
//}

どの設計が最適かは、どのような属性をもったデータを扱うか・扱うデータ量はどのくらいか・実装をシンプルにしたいか
によっても変わってきます。

カテゴリーごとに固有の属性を持った商品テーブルを扱う場合は、
@<table>{ec-product-variant-inheritance-merideri}をみながらどのような手法を選択するのがよいのか検討してみてください。
